#!/usr/bin/env bash
set -euo pipefail

POKEMON=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")
OUTDIR="pokemon_data"
ERR="errors.txt"
BASE="https://pokeapi.co/api/v2/pokemon"

mkdir -p "$OUTDIR"
: > "$ERR"                     # reset errors per run

max_retries=3
base_sleep=1               # polite rate limit

fetch_with_retry() {
  local url="$1" out="$2"

  for attempt in $(seq 1 "$max_retries"); do
    # Write to temp file; capture status code
    http_code=$(curl -sS -w "%{http_code}" -o "$out.tmp" "$url") || http_code="000"

    if [[ "$http_code" == "200" ]]; then
      if jq -e '.name' "$out.tmp" >/dev/null 2>>"$ERR"; then
        mv "$out.tmp" "$out"     # atomic publish
        return 0
      else
        echo "[$(date -Is)] Invalid JSON from $url" >> "$ERR"
        rm -f "$out.tmp"; return 1
      fi
    fi

    # Transient classes: 429 (rate limit), 5xx (server), 000 (network curl error)
    if [[ "$http_code" == "429" || "$http_code" == 5* || "$http_code" == "000" ]]; then
      sleep_time=$(( base_sleep * 2 ** (attempt - 1) ))
      echo "[$(date -Is)] HTTP $http_code for $url. Retry in ${sleep_time}s (try $attempt/$max_retries)" >> "$ERR"
      sleep "$sleep_time"; continue
    fi

    # Other 4xx: permanent (don’t retry)
    echo "[$(date -Is)] Permanent error HTTP $http_code for $url" >> "$ERR"
    rm -f "$out.tmp"; return 1
  done

  echo "[$(date -Is)] Failed after $max_retries attempts: $url" >> "$ERR"
  rm -f "$out.tmp"; return 1
}

for p in "${POKEMON[@]}"; do
  p_lc="${p,,}"
  url="$BASE/$p_lc"
  out="$OUTDIR/${p_lc}.json"
  echo "Fetching data for ${p_lc}..."
  if fetch_with_retry "$url" "$out"; then
    echo "Saved data to $out ✅"
  else
    echo "Skipping ${p_lc} due to repeated failures ❌"
  fi
  sleep 1
done